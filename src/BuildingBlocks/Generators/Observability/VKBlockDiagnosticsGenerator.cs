using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using VK.Blocks.Generators.Extensions;

namespace VK.Blocks.Generators.Observability;

[Generator]
public sealed class VKBlockDiagnosticsGenerator : IIncrementalGenerator
{
    // The fully-qualified name of the trigger attribute that this generator looks for.
    private const string _attributeFullName = "VK.Blocks.Core.Attributes.VKBlockDiagnosticsAttribute";

    private record BlockInfo(string Namespace, string ClassName, string BlockName, string Version, string Modifiers);

    /// <inheritdoc />
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var classTargets = context.SyntaxProvider
                .ForAttributeWithMetadataName(
                  _attributeFullName,
                  predicate: IsPartialClass,
                  transform: TransformToTarget)
                .WhereNotNull();

        context.RegisterSourceOutput(classTargets, (ctx, info) => EmitAttributeSource(ctx, info));
    }

    // -------------------------------------------------------------------------
    // Pipeline predicates / transforms
    // -------------------------------------------------------------------------

    private static bool IsPartialClass(SyntaxNode node, System.Threading.CancellationToken _)
        => node is ClassDeclarationSyntax cls &&
           cls.Modifiers.Any(m => m.IsKind(Microsoft.CodeAnalysis.CSharp.SyntaxKind.PartialKeyword));


    private static BlockInfo? TransformToTarget(
        GeneratorAttributeSyntaxContext ctx,
        System.Threading.CancellationToken _)
    {
        var attr = ctx.Attributes[0];
        var blockName = attr.ConstructorArguments[0].Value?.ToString();
        var version = attr.NamedArguments
                            .FirstOrDefault(x => x.Key == "Version").Value.Value?.ToString()
                        ?? "1.0.0";

        if (blockName is null)
            return null;

        var classSymbol = (INamedTypeSymbol)ctx.TargetSymbol;

        // Reconstruct access + static modifier from the symbol so the generated
        // partial declaration matches the user's original class exactly.
        var accessibility = classSymbol.DeclaredAccessibility switch
        {
            Accessibility.Public => "public",
            Accessibility.Internal => "internal",
            Accessibility.Private => "private",
            Accessibility.Protected => "protected",
            Accessibility.ProtectedOrInternal => "protected internal",
            Accessibility.ProtectedAndInternal => "private protected",
            _ => "internal"
        };
        var isStatic = classSymbol.IsStatic ? " static" : string.Empty;
        var modifiers = $"{accessibility}{isStatic}";

        return new BlockInfo(
            Namespace: classSymbol.ContainingNamespace.ToDisplayString(),
            ClassName: classSymbol.Name,
            BlockName: blockName,
            Version: version,
            Modifiers: modifiers
        );
    }

    // -------------------------------------------------------------------------
    // Source emitters
    // -------------------------------------------------------------------------

    private static void EmitAttributeSource(SourceProductionContext ctx, BlockInfo info)
    {
        var attributeSource = $$"""
                // <auto-generated/>
                using System.Diagnostics;
                using System.Diagnostics.Metrics;

                namespace {{info.Namespace}};

                {{info.Modifiers}} partial class {{info.ClassName}}
                {
                    public static readonly ActivitySource Source
                        = new("{{info.BlockName}}", "{{info.Version}}");

                    public static readonly Meter Meter
                        = new("{{info.BlockName}}", "{{info.Version}}");
                }
                """;

        ctx.AddSource($"{info.ClassName}.g.cs", attributeSource);
    }


    private sealed record ClassTarget(string Namespace, string ClassName);
}
